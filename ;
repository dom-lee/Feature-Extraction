/*******************************************************************************
 * File:        feature_extractor.cpp
 *
 * Author:      Dongmyeong Lee (domlee[at]umich.edu)
 * Created:     05/30/2022
 *
 * Description: Extract Curb and boundary of grass with LiDAR
*******************************************************************************/
#include "feature_extraction/feature_extractor.h"

using namespace bipedlab;

FeatureExtractor::FeatureExtractor(lidar_setting_t lidar_setting) 
{
    // Set Property of LiDAR
    elevation_angles_ = lidar_setting.elevation_angles;
    estimated_lidar_height_ = lidar_setting.height;
    origin_ = pcl::PointXYZ(0, 0, 0);

    // Segmentation Option
    section_direction_ = {{ 
        {-1, 0}, {-0.7071, -0.7071}, {0, -1}, {0.7071, -0.7071},
        {1, 0}, {0.7071, 0.7071}, {0, 1}, {-0.7071, 0.7071} }};
   
    base_plane_updated_ = false;

    debugger::debugTitleTextOutput("[Feature Extractor]", "Constructed", 10, BC);
}

void FeatureExtractor::changeSetting(feature_extractor_setting_t setting)
{
    setting_ = setting;

    debugger::debugTitleTextOutput("[Feature Extractor]", "Setting Changed", 10, BG);
}

void FeatureExtractor::setInputCloud(
    std::array<pcl::PointCloud<pcl::PointXYZ>, RING_NUMBER>& rings)
{
    a_test_.clear();
    b_test_.clear();
    c_test_.clear();
    landmark_.clear();


    // Estimate Base Plane
    if (!estimateBasePlane_(rings))
    {
        return;
    }
    
    // Transform the Point Cloud to make base parallel to the XY plane
    for (int i = 0; i < RING_NUMBER; ++i)
    {
        pcl::transformPointCloud(rings[i], transformed_rings_[i], transformation_);

        // Sort Rings by azimuth
        std::sort(transformed_rings_[i].begin(), transformed_rings_[i].end(),
            [](const pcl::PointXYZ& lhs, const pcl::PointXYZ& rhs)
            {
                return std::atan2(lhs.y, lhs.x) < std::atan2(rhs.y, rhs.x);
            }
        );
    }

    debugger::debugColorTextOutput("Finish SetInputCloud", 1, BG);
}

void FeatureExtractor::run()
{
    if (base_plane_updated_)
    {
        debugger::debugColorTextOutput("[Feature Extractor] Execute", 5, BW);
        extractGround_();
        //estimateRoadModel_();
        extractCurb_();
    }
    else
    {
        debugger::debugColorTextOutput("[Feature Extractor] Base Error", 10, BY);
    }
}

// Getter Functions
pcl::PointCloud<pcl::PointXYZ>::Ptr FeatureExtractor::getGround()
{
    pcl::PointCloud<pcl::PointXYZ> ground;
    for (int i = 0; i < setting_.RING_TO_ANALYZE; ++i)
    {
        ground += ground_[i];
    }

    return ground.makeShared();
}

pcl::PointCloud<pcl::PointXYZ>::Ptr FeatureExtractor::getObstacles()
{
    return obstacles_.makeShared();
}

pcl::PointCloud<pcl::PointXYZ>::Ptr FeatureExtractor::getLandmark()
{
    return landmark_.makeShared();
}

pcl::PointCloud<pcl::PointXYZ>::Ptr FeatureExtractor::getA()
{
    return a_test_.makeShared();
}

pcl::PointCloud<pcl::PointXYZ>::Ptr FeatureExtractor::getB()
{
    return b_test_.makeShared();
}

pcl::PointCloud<pcl::PointXYZ>::Ptr FeatureExtractor::getC()
{
    return c_test_.makeShared();
}

std::vector<std::pair<double, double>> FeatureExtractor::getBottomBeam()
{
    std::vector<std::pair<double, double>> beam_lines;
    for (auto& beam : bottom_beam_)
    {
        beam_lines.push_back({0, 0});
        beam_lines.push_back(beam);
    }
    return beam_lines;
}

std::vector<std::pair<double, double>> FeatureExtractor::getTopBeam()
{
    std::vector<std::pair<double, double>> beam_lines;
    for (auto& beam : top_beam_)
    {
        beam_lines.push_back({intersection_.first, intersection_.second});
        beam_lines.push_back(beam);
    }
    return beam_lines;
}

Eigen::Vector4f FeatureExtractor::getBasePlane()
{
    Eigen::Vector4f base_coeff;
    base_coeff << base_coeff_.values[0], base_coeff_.values[1],
                  base_coeff_.values[2], base_coeff_.values[3];

    return base_coeff;
}

template <class PointT>
double FeatureExtractor::calculateHeight(const PointT& point)
{
    double azimuth = std::atan2(point.y, point.x);
    double distance = pcl::euclideanDistance(point, origin_);

    int q = int(azimuth * 4 / M_PI + 4.5) % 8;
    int k = 0;
    while (k < section_distances_[q].size() &&
           distance >= section_distances_[q][k])
    {
        k++;
    }
    k--;

    Eigen::Vector4f plane_coeff = Eigen::Vector4f::Map(
        multi_region_plane_coeff_[q][k].values.data(), 4);

    return pcl::pointToPlaneDistanceSigned(point, plane_coeff);
}

template <class PointT>
bool FeatureExtractor::estimateBasePlane_(
    std::array<pcl::PointCloud<PointT>, RING_NUMBER>& rings)
{
    // Sampling Candidates for Base Planar without Obstacles
    pcl::PointCloud<PointT> base_candidate;
    for (int i = 0; i < setting_.RING_TO_FIT_BASE; ++i)
    {
        // Sort Rings by azimuth
        std::sort(rings[i].begin(), rings[i].end(),
            [](const pcl::PointXYZ& lhs, const pcl::PointXYZ& rhs)
            {
                return std::atan2(lhs.y, lhs.x) < std::atan2(rhs.y, rhs.x);
            }
        );

        int ring_size = rings[i].size();

        // Smoothness Filter (ex. Remove Grass and Obstacles)
        std::vector<double> dist_diff_ones(ring_size);
        std::vector<double> dist_diff_two(ring_size);
        for (int j = 0; j < ring_size; ++j)
        {
            pcl::PointXYZ& p_prev = rings[i][(j - 1 + ring_size) % ring_size];
            pcl::PointXYZ& p_curr = rings[i][j];
            pcl::PointXYZ& p_next = rings[i][(j + 1) % ring_size];

            dist_diff_ones[j] = pcl::euclideanDistance(p_prev, p_curr) + 
                                pcl::euclideanDistance(p_curr, p_next);
            dist_diff_two[j]  = pcl::euclideanDistance(p_prev, p_next);
        }

        for (int j = 0; j < ring_size; ++j)
        {
            double smoothness_coeff = dist_diff_two[j] / dist_diff_ones[j];
            for (int w = 1; w < setting_.SMOOTH_WINDOW_SIZE; ++w)
            {
                int w_prev = (j - w + ring_size) % ring_size;
                int w_next = (j + w) % ring_size;

                smoothness_coeff += dist_diff_two[w_prev] / dist_diff_ones[w_prev];
                smoothness_coeff += dist_diff_two[w_next] / dist_diff_ones[w_next];
            }
            smoothness_coeff /= (2 * setting_.SMOOTH_WINDOW_SIZE - 1);

            if (smoothness_coeff > setting_.SMOOTH_THRESHOLD)
            {
                base_candidate.push_back(rings[i][j]);
            }
        } // End of Smoothness Filte
    } // Finish Sampling Candidates for Base

    if (base_candidate.size() < 10)
    {
        PCL_ERROR("Not Enough Candidates for Base estimation \n");
        base_plane_updated_ = false;
        return false;
    }

    // Set Base Planar Model (ax + by + cz + d = 0)
    auto tmp_base_coeff = estimatePlaneRANSAC_(base_candidate);
    debugger::debugColorOutput("Base Coefficients \n", tmp_base_coeff, 3, BG); 

    // Sanity Check for Vertical Base Planar
    if (tmp_base_coeff.values[2] < 0.8)
    {
        PCL_ERROR("Base Planar Model is Vertical! \n");
        base_plane_updated_ = false;
        return false;
    }

    base_plane_updated_ = true;
    base_coeff_ = tmp_base_coeff;

    double a = base_coeff_.values[0];
    double b = base_coeff_.values[1];
    double c = base_coeff_.values[2];
    double d = base_coeff_.values[3];

    base_coeff_vec_ << a, b, c, d;

    // Calculated Transformation Matrix
    // Rotation Matrix
    // Row-Wise Normalized 
    // | c  0 -a |
    // | 0  c -b |
    // | a  b  c | 
    transformation_ = Eigen::Matrix4f::Identity(4, 4);
    transformation_.block<3, 3>(0, 0) << c, 0, -a, 0, c, -b, a, b, c;
    transformation_.rowwise().normalize();

    debugger::debugColorOutput("Transformation \n", transformation_, 3, BB); 
    
    // Estimated LiDAR Height from ground : |d| 
    estimated_lidar_height_ = std::abs(base_coeff_.values[3]);
    debugger::debugColorOutput("Estimated LiDAR Height : ",
                               estimated_lidar_height_, 5, BW); 

    return true;
}

template <class PointT>
pcl::ModelCoefficients FeatureExtractor::estimatePlaneRANSAC_(
    pcl::PointCloud<PointT>& cloud)
{
    // Plane Model segmentation with RANSAC
    // https://pcl.readthedocs.io/en/latest/planar_segmentation.html
    pcl::ModelCoefficients plane_coeff; 
    if (cloud.size() < 10)
    {
        debugger::debugColorTextOutput("Not enough Data for RANSAC", 5, BY);
        return plane_coeff;
    }

    pcl::PointIndices inliers;

    // Create the segmentation object
    pcl::SACSegmentation<PointT> seg;
    // Optional
    seg.setOptimizeCoefficients(true);
    // Mandatory
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setDistanceThreshold(setting_.FIT_PLANE_THRESHOLD);
    
    // Segment Planar Model
    seg.setInputCloud(cloud.makeShared());
    seg.segment(inliers, plane_coeff);

    if (inliers.indices.empty())
    {
        PCL_ERROR("Could not estimate a planar model for the given dataset.\n");
    }

    return plane_coeff;
}

void FeatureExtractor::extractGround_()
{
    // Clear Old Data
    obstacles_.clear();
    for (int i = 0; i < RING_NUMBER; ++i)
    {
        ground_[i].clear();
    }

    // Grid Specification (Grid size is odd)
    double grid_length = setting_.GRID_LENGTH;
    int grid_size = 2 * setting_.GRID_RANGE + 1;
    double max_distance = grid_length * (setting_.GRID_RANGE + 0.5);

    // Index of Center Grid
    int center_m = setting_.GRID_RANGE;
    int center_n = setting_.GRID_RANGE;

    // {min_height, max_height} for grid
    std::vector<std::vector<double>> grid_min_z(grid_size,
        std::vector<double>(grid_size, INFINITY));
    std::vector<std::vector<double>> grid_max_z(grid_size,
        std::vector<double>(grid_size, -INFINITY));

    // count of Grass Point for grid
    std::vector<std::vector<int>> grid_grass_count(grid_size,
        std::vector<int>(grid_size, 0));

    // Transformed PointCloud in Grid
    std::vector<std::vector<pcl::PointCloud<pcl::PointXYZL>>> grid_cloud(grid_size,
        std::vector<pcl::PointCloud<pcl::PointXYZL>>(grid_size));

    // Pre-Compute Grid for Filtering Ground
    for (int i = 0; i < RING_NUMBER; ++i)
    {
        int ring_size = transformed_rings_[i].size();

        // Pre-Compute Grid
        for (int j = 0; j < ring_size; ++j)
        {
            pcl::PointXYZ& point = transformed_rings_[i][j];

            // Filter outside points
            if ((point.x < 2.0 && point.x > -5.0 && std::abs(point.y) < 3.0) ||
                std::abs(point.x) >= max_distance || 
                std::abs(point.y) >= max_distance)
            {
                continue;
            }

            // Index of Grid 
            int m = center_m + (point.x + grid_length / 2) / grid_length;
            int n = center_n + (point.y + grid_length / 2) / grid_length;

            // Update Only Height Difference is less than threshold
            // To avoid ground included grid (Trees Branches, Vehicle)
            if (!std::isinf(grid_max_z[m][n]) && 
                point.z - grid_max_z[m][n] > setting_.DISCONTINUITY_HEIGHT)
            {
                obstacles_.push_back(point);
                continue;
            }
           
            // Update Min/Max Height
            grid_min_z[m][n] = std::min((double)point.z, grid_min_z[m][n]);
            grid_max_z[m][n] = std::max((double)point.z, grid_max_z[m][n]);

            // Update PointCloud in Grid
            pcl::PointXYZL point_with_label;
            point_with_label.x = point.x;
            point_with_label.y = point.y;
            point_with_label.z = point.z;
            point_with_label.label = i;

            grid_cloud[m][n].push_back(point_with_label);

            // Filter Grass with Smooth Filter (ex. Grass)
            if (i < 3)
            {
                continue;
            }

            pcl::PointXYZ& point_prev = transformed_rings_[i][(j - 1 + ring_size) % ring_size];
            pcl::PointXYZ& point_next = transformed_rings_[i][(j + 1) % ring_size];
            double dist_diff_ones = pcl::euclideanDistance(point_prev, point) + 
                                    pcl::euclideanDistance(point, point_next);
            double dist_diff_two  = pcl::euclideanDistance(point_prev, point_next);
            double smoothness_coeff = dist_diff_two / dist_diff_ones;
            if(smoothness_coeff < setting_.SMOOTH_THRESHOLD)
            {
                //a_test_.push_back(point);
                grid_grass_count[m][n]++;
            }

        }
    } // End of Pre-Compute Grid

    // Estimate whether Cell is Ground or Not
    // -1 : Obstacle (Building, Vehicle, Grass)
    //  0 : Unknown
    //  1 : Ground
    grid_ground_ = std::vector<std::vector<int>>(grid_size,
                                                 std::vector<int>(grid_size, 0));
    std::vector<std::pair<int, int>> neighbors =
        {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};

    // Asign Center of Grid as Ground
    grid_ground_[center_m][center_n] = 1;
    Eigen::Vector4f transformed_base_coeff = transformation_ * base_coeff_vec_;
    grid_min_z[center_m][center_n] = -transformed_base_coeff(3);
    grid_max_z[center_m][center_n] = -transformed_base_coeff(3);

    // Check Ground by propagation
    for (int range = 1; range <= setting_.GRID_RANGE; ++range)
    {
        std::vector<std::pair<int, int>> m_n_idx_list;
        // Top-Right to Top-Left
        for (int m = center_m + range, n = center_n - range;
             n < center_n + range ; ++n)
        {
            m_n_idx_list.push_back({m, n});
        }
        // Top-Left to Bottom-Left
        for (int m = center_m + range, n = center_n + range;
             m > center_m - range ; --m)
        {
            m_n_idx_list.push_back({m, n});
        }
        // Bottom-Left to Bottom-Right
        for (int m = center_m - range, n = center_n + range;
             n > center_n - range ; --n)
        {
            m_n_idx_list.push_back({m, n});
        }
        // Bottom-Right to Top-Right
        for (int m = center_m - range, n = center_n - range;
             m < center_m + range ; ++m)
        {
            m_n_idx_list.push_back({m, n});
        }
        
        // Iterate over Current Range of Cells
        for (auto& m_n_idx : m_n_idx_list)
        {
            int m = m_n_idx.first;
            int n = m_n_idx.second;

            // Check whether grid is ground based on neighbor ground
            double max_z_neighbor_ground = -INFINITY;
            double min_z_neighbor_ground = INFINITY;
            int neighbor_count = 0;
            int empty_neighbor_count = 0;
            // Count neighbors Grass Point
            int grass_points_count = grid_grass_count[m][n];
            int total_neighbor_count = grid_cloud[m][n].size();
            for (auto& neighbor : neighbors)
            {
                int tmp_m = m + neighbor.first;
                int tmp_n = n + neighbor.second;

                // Out of Grid
                if (tmp_m < 0 || tmp_m >= grid_size ||
                    tmp_n < 0 || tmp_n >= grid_size)
                {
                    continue;
                }

                // Grass Neighbor
                grass_points_count += grid_grass_count[tmp_m][tmp_n];
                total_neighbor_count += grid_cloud[tmp_m][tmp_n].size();

                // Update Min/Max Z value for neighbor ground
                // Only Consider Inner grid
                int range_neighbor = std::max(std::abs(tmp_m - center_m),
                                              std::abs(tmp_n - center_n));
                if (range_neighbor >= range)
                {
                    continue;
                }
                min_z_neighbor_ground = std::min(min_z_neighbor_ground,
                                                 grid_min_z[tmp_m][tmp_n]);
                max_z_neighbor_ground = std::max(max_z_neighbor_ground,
                                                 grid_max_z[tmp_m][tmp_n]);
            }

            // Update Min/Max Z value for Empty Cell
            if (grid_cloud[m][n].empty())
            {
                grid_ground_[m][n] = 0;

                // Reset Min/Max Z value for obstacle for ground propagation
                grid_max_z[m][n] = max_z_neighbor_ground;
                grid_min_z[m][n] = min_z_neighbor_ground;

                continue;
            }

            // Set Obstacle by checking height difference or 
            // Check Height Difference with Neighbor Ground Cells 
            // [*Important*] DownSlope has longer distance between ring
            double grid_height_diff = grid_max_z[m][n] -
                                      std::min(grid_min_z[m][n], max_z_neighbor_ground);
            if (grid_height_diff > setting_.OBSTACLE_THRESHOLD ||
                grid_max_z[m][n] > max_z_neighbor_ground + setting_.GROUND_THRESHOLD ||
                grid_min_z[m][n] < min_z_neighbor_ground - 3 * setting_.GROUND_THRESHOLD)
            {
                grid_ground_[m][n] = -1;
                grid_grass_count[m][n] = 0;

                // Reset Min/Max Z value for obstacle for ground propagation
                grid_max_z[m][n] = max_z_neighbor_ground;
                grid_min_z[m][n] = min_z_neighbor_ground;

                continue;
            }

            // Set Cell as Grass
            if (grass_points_count > setting_.GRASS_COUNT_THRESHOLD &&
                grass_points_count > setting_.GRASS_RATIO_THRESHOLD * total_neighbor_count)
            {
                grid_ground_[m][n] = -1;

                continue;
            }

            // Asign the Cell as Ground
            grid_ground_[m][n] = 1;
        }
    }

    // Save Ground and Obstacles after smoothing
    for (int m = 0; m < grid_size; ++m)
    {
        for (int n = 0; n < grid_size; ++n)
        {
            // Skip the empty Cell
            if (grid_cloud[m][n].empty())
            {
                continue;
            }

            // Save PointCloud into Ground / Obstacles
            for (auto& point_with_label : grid_cloud[m][n])
            {
                pcl::PointXYZ point;
                point.x = point_with_label.x;
                point.y = point_with_label.y;
                point.z = point_with_label.z;

                if (grid_ground_[m][n] != 1)
                {
                    obstacles_.push_back(point);
                }
                else
                {
                    ground_[point_with_label.label].push_back(point);
                }
            }
        }
    }

    // Sort Point Cloud by Couter Clock-wisely
    for (int i = 0; i < ground_.size(); ++i)
    {
        std::sort(ground_[i].begin(), ground_[i].end(),
            [](const pcl::PointXYZ& lhs, const pcl::PointXYZ& rhs)
            {
                return std::atan2(lhs.y, lhs.x) < std::atan2(rhs.y, rhs.x);
            }
        );
    }
}

void FeatureExtractor::estimateRoadModel_()
{
    bottom_beam_.clear();
    top_beam_.clear();

    // Bottom Layer Beam Model (emit beam based on LiDAR Origin)
    double max_score = processBeamModel_(0, 0, bottom_beam_);

    // Top Layer Beam Model
    for (auto& beam : bottom_beam_)
    {
        for (int i = 0; i < 30; ++i)
        {
            double theta = std::atan2(beam.second, beam.first);
            double x = (i + 1) * std::cos(theta);
            double y = (i + 1) * std::sin(theta);

            std::vector<std::pair<double, double>> new_beam;
            double score = processBeamModel_(x, y, new_beam);
            
            if (score > max_score)
            {
                max_score = score;
                intersection_ = {x, y};
                top_beam_ = new_beam;
            }
        }
    }

    std::pair<double, double> intersection = intersection_;
    std::vector<std::pair<double, double>> top_beam = top_beam_;
    for (auto& beam : top_beam)
    {
        for (int i = 0; i < 5; ++i)
        {
            double theta = std::atan2(beam.second - intersection.second,
                                      beam.first  - intersection.first);
            double x = intersection.first  + (i + 1) * std::cos(theta);
            double y = intersection.second + (i + 1) * std::sin(theta);

            std::vector<std::pair<double, double>> new_beam;
            double score = processBeamModel_(x, y, new_beam);
            if (score > max_score)
            {
                max_score = score;
                intersection_ = {x, y};
                top_beam_ = new_beam;
            }
        }
    }
}

void FeatureExtractor::extractCurb_()
{
    for (int i = 0; i < ground_.size(); ++i)
    {
        if (ground_[i].empty())
        {
            continue;
        }

        int ring_size = ground_[i].size();

        // Precompute Line Section
        std::vector<std::pair<pcl::PointXYZ, pcl::PointXYZ>> feature_lines;
        int smooth_points_count = 1;
        pcl::PointXYZ start_point = ground_[i][0];
        double azimuth_curr = std::atan2(start_point.y, start_point.x);
        for (int j = 1; j < ring_size - 1; ++j)
        {
            pcl::PointXYZ& point_curr = ground_[i][j];
            pcl::PointXYZ& point_next = ground_[i][j + 1];

            // Check Discontinuity
            double azimuth_next = std::atan2(point_next.y, point_next.x);
            bool is_discontinued = (azimuth_next - azimuth_curr >
                                    setting_.DISCONTINUITY_AZIMUTH);

            // Get Vector segment for elements (Curb, Road) by checking Smoothness
            Eigen::Vector3f v_a = start_point.getVector3fMap() -
                                  point_curr.getVector3fMap();
            Eigen::Vector3f v_b = point_next.getVector3fMap() -
                                  point_curr.getVector3fMap();

            double angle = std::acos(v_a.dot(v_b) / v_a.norm() / v_b.norm());
            double distance = pcl::euclideanDistance(start_point, point_curr);
            if (is_discontinued || angle < setting_.SMOOTH_DIST_CURB)
            {
                if (distance> setting_.SMOOTH_DISTANCE_THRESHOLD)
                {
                    feature_lines.push_back({start_point, point_curr});
                    a_test_.push_back(start_point);
                    b_test_.push_back(point_curr);
                }
                
                smooth_points_count = 1;
                start_point = is_discontinued ? point_next : point_curr;
            }
            else
            {
                smooth_points_count++;
            }
            
            azimuth_curr = azimuth_next;
        }

        if (smooth_points_count >= setting_.SMOOTH_COUNT_THRESHOLD)
        {
            feature_lines.push_back({start_point, ground_[i].back()});
            a_test_.push_back(start_point);
            b_test_.push_back(ground_[i].back());
        } // End of Pre-Computing Feature Lines
        
        // Execute Curb Extraction with FeatureLines
        for (int k = 1; k < (int)feature_lines.size() - 1; ++k)
        {
            pcl::PointXYZ& start_curr = feature_lines[k].first;
            pcl::PointXYZ& end_curr   = feature_lines[k].second;
            pcl::PointXYZ& start_next = feature_lines[k + 1].first;
            pcl::PointXYZ& end_next   = feature_lines[k + 1].second;
            pcl::PointXYZ& start_prev = feature_lines[k - 1].first;
            pcl::PointXYZ& end_prev   = feature_lines[k - 1].second;

            if (end_curr.z - start_next.z > setting_.CURB_HEIGHT_THRESHOLD &&
                pcl::euclideanDistance(origin_, start_next) >
                pcl::euclideanDistance(origin_, end_curr))
            {
                c_test_.push_back(end_curr);
            }

        }
    }




         
            //// 1. Skip when adjancent two points are close by checking XY Gap
            //double distance_xy = distances_xy[j];
            //double gap_xy_prev = gap_xy_dist[j];
            //double gap_xy_next = gap_xy_dist[(j + 1) % ring_size];
            //double delta_xy = distance_xy * setting_.ANGULAR_RESOLUTION;
            //if (gap_xy_prev < delta_xy && gap_xy_next < delta_xy)
            //{
                //continue;
            //}

            //// 2. Skip Discontinued Points
            //double azimuth      = azimuths[j];
            //double azimuth_prev = azimuths[(j - 1 + ring_size) % ring_size];
            //double azimuth_next = azimuths[(j + 1) % ring_size];
            //if (azimuth_next - azimuth > setting_.DISCONTINUITY_AZIMUTH ||
                //azimuth - azimuth_prev > setting_.DISCONTINUITY_AZIMUTH)
            //{
                //continue;
            //}
            
            //// 3. Smooth Filter (ex. Grass)
            //// [* Note *] Mark that smoothness_coeff doesn't include itself
            //double smoothness_coeff = 1.0;
            //while (smoothness_coeff ? setting_.SMOOTH_THRESHOLD_CURB)
            //{

            //}
               
            //double smoothness_coeff = 0;
            //for (int w = 2; w < setting_.SMOOTH_WINDOW_SIZE; ++w)
            //{
                //int w_prev = (j - w + ring_size) % ring_size;
                //int w_next = (j + w) % ring_size;

                //smoothness_coeff += dist_diff_two[w_prev] / dist_diff_ones[w_prev];
                //smoothness_coeff += dist_diff_two[w_next] / dist_diff_ones[w_next];
            //}
            //smoothness_coeff /= (2 * setting_.SMOOTH_WINDOW_SIZE - 4);

            //if (smoothness_coeff < setting_.SMOOTH_THRESHOLD)
            //{
                //continue;
            //}

         
            //// Select #1. Using discontinued point
            //// (When LiDAR cannot detect vertical surface of Curb)
            //double dist_origin      = distances_origin[j];
            //double dist_origin_prev = distances_origin[(j - 1 + ring_size) % ring_size];
            //double dist_origin_next = distances_origin[(j + 1) % ring_size];
            //double theta = std::acos(estimated_lidar_height_ / dist_origin);
            //double dist_diff_threshold = setting_.CURB_HEIGHT_THRESHOLD / std::cos(theta);
            //if (dist_origin_prev - dist_origin > dist_diff_threshold &&
                 //std::abs(dist_origin_next - dist_origin) < delta_xy &&
                 //point.z - point_prev.z > setting_.CURB_HEIGHT_THRESHOLD)
            //{
            //}

            //if (dist_origin_next - dist_origin > dist_diff_threshold &&
                 //std::abs(dist_origin_prev - dist_origin) < delta_xy &&
                 //point.z - point_next.z > setting_.CURB_HEIGHT_THRESHOLD)
            //{
            //}



            // Property(Distance) of Points
            //double dist_origin = pcl::euclideanDistance(origin_, point);
            //double dist_origin_prev = pcl::euclideanDistance(origin_, point_prev);
            //double dist_origin_next = pcl::euclideanDistance(origin_, point_next);

            //double theta = std::acos(estimated_lidar_height_ / dist_origin);

            //double dist_diff_prev = dist_origin_prev - dist_origin;
            //double dist_diff_next = dist_origin_next - dist_origin;
            //double dist_diff_threshold = setting_.CURB_HEIGHT_THRESHOLD / std::cos(theta);
            //if ((dist_diff_prev > dist_diff_threshold &&
                 //dist_diff_prev < setting_.CURB_ANGLE_THRESHOLD * dist_diff_threshold &&
                 //std::abs(dist_diff_next) < setting_.CURB_HEIGHT &&
                 //point.z - point_prev.z > setting_.CURB_HEIGHT_THRESHOLD &&
                 //std::abs(point.z - point_next.z) < setting_.CURB_HEIGHT) ||
                //(dist_diff_next > dist_diff_threshold &&
                 //dist_diff_next < setting_.CURB_ANGLE_THRESHOLD * dist_diff_threshold &&
                 //std::abs(dist_diff_prev) < setting_.CURB_HEIGHT &&
                 //point.z - point_next.z > setting_.CURB_HEIGHT_THRESHOLD &&
                 //std::abs(point.z - point_prev.z) < setting_.CURB_HEIGHT))
            //{
                //landmark_.push_back(point);
            //}

            //// 1. Discontinuity (for local window size)
            //pcl::PointXYZ& point_prev_window = 
                //ground_[i][(j - setting_.CURB_WINDOW_SIZE + ring_size) % ring_size];
            //pcl::PointXYZ& point_next_window =
                //ground_[i][(j + setting_.CURB_WINDOW_SIZE + ring_size) % ring_size];

            //double dist_xy_prev_window = std::sqrt(
                //std::pow(point_prev_window.x - point.x, 2) +
                //std::pow(point_prev_window.y - point.y, 2));
            //double dist_xy_next_window = std::sqrt(
                //std::pow(point_next_window.x - point.x, 2) +
                //std::pow(point_next_window.y - point.y, 2));

            //double discontinuity_threshold = setting_.DISCONTINUITY * delta_xy;
            //if (dist_xy_prev_window > discontinuity_threshold ||
                //dist_xy_next_window > discontinuity_threshold)
            //{
                //continue;
            //}
        
            //// 1. Height & Angular Filter
            //double max_height = ground_height_[i][j];
            //double min_height = ground_height_[i][j];
            
            //Eigen::Vector2f v_a(0.0, 0.0);
            //int count_a = 1;
            //double dist_diff_a = 0.0;
            //double distance_xy_a = 0.0;
            //while (dist_diff_a < delta_xy * n_v && count_a < n_v)
            //{
                //int idx_a = (j + count_a + ring_size) % ring_size;
                //const pcl::PointXYZ& p_a = ground_[i][idx_a];

                //v_a(0) += (p_a.x - point.x);
                //v_a(1) += (p_a.y - point.y);

                //max_height = std::max(max_height, ground_height_[i][idx_a]);
                //min_height = std::min(min_height, ground_height_[i][idx_a]);

                //dist_diff_a = std::sqrt(std::pow(p_a.x - point.x, 2) +
                                        //std::pow(p_a.y - point.y, 2));
                //count_a++;
            //}
            
            //Eigen::Vector2f v_b(0.0, 0.0);
            //int count_b = 1;
            //double dist_diff_b = 0.0;
            //double distance_xy_b = 0.0;
            //while (dist_diff_b < delta_xy * n_v && count_b < n_v)
            //{
                //int idx_b = (j - count_b + ring_size) % ring_size;
                //const pcl::PointXYZ& p_b = ground_[i][idx_b];

                //v_b(0) += (p_b.x - point.x);
                //v_b(1) += (p_b.y - point.y);

                //max_height = std::max(max_height, ground_height_[i][idx_b]);
                //min_height = std::min(min_height, ground_height_[i][idx_b]);

                //dist_diff_b = std::sqrt(std::pow(p_b.x - point.x, 2) +
                                        //std::pow(p_b.y - point.y, 2));
                //count_b++;
            //}

            //double angle_window = std::acos(v_a.dot(v_b) / v_a.norm() / v_b.norm());
            //if (angle_window > setting_.CURB_ANGLE_THRESHOLD)
            //{
                //continue;
            //}

            //if (max_height - min_height > setting_.CURB_HEIGHT_THRESHOLD)
            //{
                //landmark_.push_back(point);
            //}



            //// 4. Angular & Height Filter
            //// Compute Multi-Region Segment idx
            //int q = int(azimuth * 4 / M_PI + 4.5) % 8;
            //int k = 0;
            //while (k < section_distances_[q].size() && 
                    //distance >= section_distances_[q][k])
            //{
                //k++;
            //}
            //k--;

            //// planar model
            //pcl::ModelCoefficients& plane_coeff = multi_region_plane_coeff_[q][k];
            //double a = plane_coeff.values[0];
            //double b = plane_coeff.values[1];
            //double c = plane_coeff.values[2];
            //double d = plane_coeff.values[3];

            //// Height of point based on the planar model
            //double height_point = pcl::pointToPlaneDistanceSigned(point, a, b, c, d);

            //// estimated number of points on CURB
            //int n_v = setting_.CURB_HEIGHT / std::sin(theta) / delta_xy;

            //Eigen::Vector2f v_a(0.0, 0.0);
            //double max_height_diff_a = 0.0;
            //int count_a = 1;
            //double dist_diff_a = 0.0;
            //double distance_xy_a = 0.0;
            //while (dist_diff_a < delta_xy * n_v && count_a < n_v)
            //{
                //pcl::PointXYZ& p_a = ground_[i][(j + count_a + ring_size) % ring_size];
                
                //double x_diff = p_a.x - point.x;
                //double y_diff = p_a.y - point.y;
                //double height_diff = pcl::pointToPlaneDistanceSigned(p_a, a, b, c, d) -
                                     //height_point;

                //dist_diff_a = std::sqrt(std::pow(x_diff, 2) + std::pow(y_diff, 2));
                //distance_xy_a = std::sqrt(std::pow(p_a.x, 2) + std::pow(p_a.y, 2));

                //v_a(0) += x_diff;
                //v_a(1) += y_diff;

                //max_height_diff_a = std::max(max_height_diff_a, height_diff);

                //count_a++;
            //}
            
            //Eigen::Vector2f v_b(0.0, 0.0);
            //double max_height_diff_b = 0.0;
            //int count_b = 1;
            //double dist_diff_b = 0.0;
            //double distance_xy_b = 0.0;
            //while (dist_diff_b < delta_xy * n_v && count_b < n_v)
            //{
                //pcl::PointXYZ& p_b = ground_[i][(j - count_b + ring_size) % ring_size];
                
                //double x_diff = p_b.x - point.x;
                //double y_diff = p_b.y - point.y;
                //double height_diff = pcl::pointToPlaneDistanceSigned(p_b, a, b, c, d) - 
                                     //height_point;

                //dist_diff_b = std::sqrt(std::pow(x_diff, 2) + std::pow(y_diff, 2));
                //distance_xy_b = std::sqrt(std::pow(p_b.x, 2) + std::pow(p_b.y, 2));

                //v_b(0) += x_diff;
                //v_b(1) += y_diff;

                //max_height_diff_b = std::max(max_height_diff_b, height_diff);

                //count_b++;
            //}
            
            //// Threshold (Discontinuity Filter for n_v) 
            //if (dist_diff_a > setting_.DISCONTINUITY * n_v * delta_xy ||
                //dist_diff_b > setting_.DISCONTINUITY * n_v * delta_xy)
            //{
                //continue;
            //}

            //// 4. Augluar Filter
            //double angle_window = std::acos(v_a.dot(v_b) / v_a.norm() / v_b.norm());
            //if (angle_window > setting_.ANGLE_CURB_THRESHOLD)
            //{
                //continue;
            //}

            //// 5. Height Filter
            //if ((max_height_diff_a > setting_.HEIGHT_CURB_THRESHOLD &&
                 //distance_xy_a < distance_xy) ||
                //(max_height_diff_b > setting_.HEIGHT_CURB_THRESHOLD &&
                 //distance_xy_b < distance_xy))
            //{
                //landmark_.push_back(point);

                ////// Prevent continuous points
                ////j += n_v;
            //}
        //}
    //}
}



void FeatureExtractor::estimateGround_()
{
    // Clear
    for (int i = 0; i < RING_NUMBER; ++i)
    {
        ground_[i].clear();
        ground_height_[i].clear();
    }

    //std::array<std::vector<pcl::ModelCoefficients>, 8> multi_region_plane_coeff_;
    for (int q = 0; q < 8; ++q)
    {
        multi_region_plane_coeff_[q].resize(section_number_);

        // Estimate Planar Model for Multi-Region
        for (int k = 0; k < section_number_; ++k)
        {
            multi_region_plane_coeff_[q][k] = estimatePlaneRANSAC_(filtered_region_[q][k]);

            debugger::debugColorOutput("# of Points (q: " + 
                std::to_string(q) + ", k: " + std::to_string(k) + ")\n", 
                filtered_region_[q][k].size(), 1, BB);

            debugger::debugColorOutput("Plane Coeff (q: " + 
                std::to_string(q) + ", k: " + std::to_string(k) + ")\n", 
                multi_region_plane_coeff_[q][k], 1, BB);
            
            pcl::ModelCoefficients& coeff_prev = (k > 0) ? 
                multi_region_plane_coeff_[q][k - 1] : base_coeff_;

            // replace with previous section planar model
            if (multi_region_plane_coeff_[q][k].values.empty())
            {
                multi_region_plane_coeff_[q][k] = coeff_prev;
            }
            // Compute Angle Difference with two plane model
            else
            {                
                double angle_diff = computeAngleTwoPlane_(coeff_prev,
                    multi_region_plane_coeff_[q][k]);
                angle_diff = std::min(angle_diff, M_PI - angle_diff);
                
                std::pair<double, double> boundary_point = 
                    {section_direction_[q].first * section_distances_[q][k],
                     section_direction_[q].second * section_distances_[q][k]};
                double height_diff = computeHeightDiffTwoPlane_(boundary_point,
                    coeff_prev, multi_region_plane_coeff_[q][k]); 

                if (M_PI / 2 - angle_diff < setting_.ANGLE_DIFF_THRESHOLD)
                {
                    debugger::debugColorTextOutput("Remove Inlier region (q: " + 
                        std::to_string(q) + ", k: " + std::to_string(k) +
                        ") : ", 2, BM);

                    // remove points that forms vertical to base
                    removeInliner_(filtered_region_[q][k],
                                   multi_region_plane_coeff_[q][k]);
                    k--;
                }
                else if (angle_diff > setting_.ANGLE_DIFF_THRESHOLD ||
                         height_diff > setting_.HEIGHT_DIFF_THRESHOLD)
                {
                    debugger::debugColorOutput("Angle Diff region (q: " + 
                        std::to_string(q) + ", k: " + std::to_string(k) +
                        ") : ", angle_diff, 2, BM);
                    debugger::debugColorOutput("Height Diff region (q: " + 
                        std::to_string(q) + ", k: " + std::to_string(k) +
                        ") : ", height_diff, 2, BM);

                    multi_region_plane_coeff_[q][k] = coeff_prev;
                }
            }
        }
    }

    // Filter with Multi-Region Plane model
    for (int q = 0; q < 8; ++q)
    {
        for (int k = 0; k < section_number_; ++k)
        {
            pcl::ModelOutlierRemoval<pcl::PointXYZL> ground_filter(true);
            ground_filter.setThreshold(setting_.GROUND_THRESHOLD);
            ground_filter.setModelType(pcl::SACMODEL_PLANE);
            ground_filter.setModelCoefficients(multi_region_plane_coeff_[q][k]);
            ground_filter.setInputCloud(multi_region_[q][k].makeShared());
            
            pcl::PointCloud<pcl::PointXYZL> ground_cloud;
            //ground_filter.setNegative(false);
            ground_filter.filter(ground_cloud);

            for (pcl::PointXYZL& p : ground_cloud)
            {
                pcl::PointXYZ point;
                point.x = p.x;
                point.y = p.y;
                point.z = p.z;

                ground_[p.label].push_back(point);
            }
            
            //pcl::PointCloud<pcl::PointXYZL> obstacle_cloud;
    //pcl::PointIndices::ConstPtr inliers = ground_filter.getRemovedIndices();
    //pcl::ExtractIndices<PointT> extract;
    //extract.setInputCloud(multi_region_[q][k].makeShared());
    //extract.setIndices(inliers);
    //extract.setNegative(true);
    //extract.filter(obstacle_cloud);
            //pcl::ModelOutlierRemoval<pcl::PointXYZL> ground_filter;
            //ground_filter.setThreshold(setting_.GROUND_THRESHOLD);
            //ground_filter.setModelType(pcl::SACMODEL_PLANE);
            //ground_filter.setModelCoefficients(multi_region_plane_coeff_[q][k]);
            //ground_filter.setInputCloud(multi_region_[q][k].makeShared());
            //pcl::PointCloud<pcl::PointXYZL> obstacle_cloud;
            //ground_filter.setNegative(true);
            //ground_filter.filter(obstacle_cloud);
            //

            
            //for (int obstacle_idx : *ground_filter.getRemovedIndices()) 
            //{
                //pcl::PointXYZ point;
                //point.x = multi_region_[q][k][obstacle_idx].x;
                //point.y = multi_region_[q][k][obstacle_idx].y;
                //point.z = multi_region_[q][k][obstacle_idx].z;

                //processObstacleForBeamModel_(multi_region_[q][k][obstacle_idx]);
            //}
        }
    }
    
    // Sort Point Cloud by Couter Clock-wisely
    for (int i = 0; i < ground_.size(); ++i)
    {
        std::sort(ground_[i].begin(), ground_[i].end(),
            [](const pcl::PointXYZ& lhs, const pcl::PointXYZ& rhs)
            {
                return std::atan2(lhs.y, lhs.x) < std::atan2(rhs.y, rhs.x);
            }
        );

        // Filter Discontinued area
        pcl::PointCloud<pcl::PointXYZ> continued_ground_ring;
        pcl::PointCloud<pcl::PointXYZ> cluster;
        int count_continued = 0;
        for (int j = 1; j < ground_[i].size(); ++j)
        {
            pcl::PointXYZ& point_curr = ground_[i][j];
            pcl::PointXYZ& point_prev = ground_[i][j - 1];

            double delta_xy = setting_.ANGULAR_RESOLUTION *
                              std::sqrt(std::pow(point_curr.x, 2) +
                                        std::pow(point_curr.y, 2));
            
            double distance = std::sqrt(
                std::pow(point_curr.x - point_prev.x, 2) +
                std::pow(point_curr.y - point_prev.y, 2));
            if (distance > setting_.GROUND_DISCONTINUITY * delta_xy)
            {
                if (count_continued > setting_.CONTINUED_NUMBER)
                {
                    continued_ground_ring += cluster;
                }
                count_continued = 0;
                cluster.clear();
            }
            else
            {
                count_continued++; 
            }
            cluster.push_back(point_curr);
        }

        if (count_continued > setting_.CONTINUED_NUMBER)
        {
            continued_ground_ring += cluster;
        }

        ground_[i] = continued_ground_ring;

        // Calculate Height of points from Base Plane
        ground_height_[i].resize(ground_[i].size());
        for (int j = 0; j < ground_[i].size(); ++j)
        {
            ground_height_[i][j] = calculateHeight(ground_[i][j]);
        }
    }
}

double FeatureExtractor::processBeamModel_(double center_x, double center_y,
    std::vector<std::pair<double, double>>& out_beam_model)
{
    if (std::abs(center_x) > setting_.ROAD_VIEW_RANGE ||
        std::abs(center_y) > setting_.ROAD_VIEW_RANGE)
    {
        return INFINITY;
    }

    out_beam_model.clear();
    double score = 0.0;
    
    // Min / Max distance for angle section
    int section_number = setting_.BEAM_SECTION_NUMBER;
    std::vector<std::pair<double, double>>min_distance_beam(section_number);
    std::vector<std::pair<double, double>>max_distance_beam(section_number);

    // Grid Property
    double grid_length = setting_.GRID_LENGTH;
    int grid_size = 2 * setting_.GRID_RANGE + 1;
    int center_m = setting_.GRID_RANGE;
    int center_n = setting_.GRID_RANGE;
    double max_distance = setting_.ROAD_VIEW_RANGE;

    // Beam Model
    double resolution = 360.0 / (double)setting_.BEAM_SECTION_NUMBER;
    for (int z = 0; z < setting_.BEAM_SECTION_NUMBER; ++z)
    {
        double theta = (resolution * z - 180 + resolution / 2.0) * M_PI / 180;

        max_distance_beam[z].first = theta;
        max_distance_beam[z].second =
            calculateDistanceInBox_(center_x, center_y, theta, max_distance);
    }

    // Calculate Min Beam distance
    min_distance_beam = max_distance_beam;
    for (int m = 0; m < grid_size; ++m)
    {
        for (int n = 0; n < grid_size; ++n)
        {
            // Skip Ground and Empty Cell
            if (grid_ground_[m][n] != -1)
            {
                continue;
            }
            
            int x = (m - center_m) * grid_length;
            int y = (n - center_n) * grid_length;
            
            if (std::abs(x) > setting_.ROAD_VIEW_RANGE ||
                std::abs(y) > setting_.ROAD_VIEW_RANGE)
            {
                continue;
            }

            double azimuth = std::atan2(y - center_y, x - center_x);
            double distance_xy = std::sqrt(std::pow(x - center_x, 2) +
                                           std::pow(y - center_y, 2));

            int idx = int((azimuth * 180 / M_PI + 180) / resolution);
            if (distance_xy < min_distance_beam[idx].second)
            {
                min_distance_beam[idx] = {azimuth, distance_xy};
            }

        }
    }

    // Count No Obstacle Section Clock-Wisely
    int max_beam_count = 0;
    for (int z = setting_.BEAM_SECTION_NUMBER - 1; z >= 0; --z)
    {
        if (min_distance_beam[z].second < max_distance_beam[z].second)
        {
            break;
        }
        max_beam_count++;
    }
    
    // Find Center of On-Road
    int last_idx = section_number - max_beam_count;
    for (int z = 0; z < last_idx; ++z)
    {
        if (min_distance_beam[z].second < max_distance_beam[z].second)
        {
            if (max_beam_count < 3)
            {
                max_beam_count = 0;
                continue;
            }

            int start_idx = (z - max_beam_count + section_number) % section_number;
            double start_x = center_x + min_distance_beam[start_idx].second *
                             std::cos(min_distance_beam[start_idx].first);
            double start_y = center_y + min_distance_beam[start_idx].second *
                             std::sin(min_distance_beam[start_idx].first);

            int end_idx = (z - 1 + section_number) % section_number;
            double end_x = center_x + min_distance_beam[end_idx].second *
                           std::cos(min_distance_beam[end_idx].first);
            double end_y = center_y + min_distance_beam[end_idx].second *
                           std::sin(min_distance_beam[end_idx].first);

            max_beam_count = 0;
            double road_width = std::sqrt(std::pow(start_x - end_x, 2) +
                                          std::pow(start_y - end_y, 2));
            if (road_width < setting_.ROAD_WIDTH_THRESHOLD)
            {
                continue;
            }

            double mean_x = (start_x + end_x) / 2;
            double mean_y = (start_y + end_y) / 2;

            // Calculate Score by counting ground cell on the beam
            std::vector<std::pair<int, int>> on_grid_idxs;
            executeBresenhamLine(center_x, center_y, mean_x, mean_y,
                                 grid_length, on_grid_idxs);
            
            double score_on_line = 0.0;
            for (auto& idx : on_grid_idxs)
            {
                if (grid_ground_[idx.first + center_m][idx.second + center_n] == 1)
                {
                    score_on_line++;
                }
            }
            
            if (score_on_line < setting_.GROUND_COUNT_THRESHOLD)
            {
                continue;
            }
            
            score += score_on_line;
            out_beam_model.push_back({mean_x, mean_y});
        }
        else
        {
            max_beam_count++;
        }
    }
    return score;
}

double FeatureExtractor::calculateDistanceInBox_(
    double center_x, double center_y, double theta, double box_length)
{
    // y = mx + b (line from center)
    double m = std::tan(theta);
    double b = -m * center_x + center_y;

    // intersection
    std::pair<double, double> intersection_vertical;
    std::pair<double, double> intersection_horizontal;
    if (theta < -M_PI / 2)
    {
        intersection_vertical.first    = -box_length;
        intersection_vertical.second   = -m * box_length + b;
        intersection_horizontal.first  = (-box_length - b) / m;
        intersection_horizontal.second = -box_length;
    }
    else if (theta < 0)
    {
        intersection_vertical.first    = box_length;
        intersection_vertical.second   = m * box_length + b;
        intersection_horizontal.first  = (-box_length - b) / m;
        intersection_horizontal.second = -box_length;
    }
    else if (theta < M_PI / 2)
    {
        intersection_vertical.first    = box_length;
        intersection_vertical.second   = m * box_length + b;
        intersection_horizontal.first  = (box_length - b) / m;
        intersection_horizontal.second = box_length;
    }
    else
    {
        intersection_vertical.first    = -box_length;
        intersection_vertical.second   = -m * box_length + b;
        intersection_horizontal.first  = (box_length - b) / m;
        intersection_horizontal.second = box_length;
    }

    double distance_to_verical = std::sqrt(
        std::pow(center_x - intersection_vertical.first, 2) + 
        std::pow(center_y - intersection_vertical.second, 2));
    double distance_to_horizontal = std::sqrt(
        std::pow(center_x - intersection_horizontal.first, 2) + 
        std::pow(center_y - intersection_horizontal.second, 2));

    return std::min(distance_to_verical, distance_to_horizontal);
}

void FeatureExtractor::executeBresenhamLine(
    double start_x, double start_y, double end_x, double end_y, double grid_length,
    std::vector<std::pair<int, int>>& out_grid_idxs)
{
    out_grid_idxs.clear();
    
    int x0 = std::floor((start_x + grid_length / 2) / grid_length);
    int y0 = std::floor((start_y + grid_length / 2) / grid_length);
    int x1 = std::floor((end_x + grid_length / 2) / grid_length);
    int y1 = std::floor((end_y + grid_length / 2) / grid_length);
    
    double dx = std::abs(x1 - x0);
    double sx = (x0 < x1) ? 1 : -1;
    double dy = -std::abs(y1 - y0);
    double sy = (y0 < y1) ? 1 : -1;
    double error = dx + dy;

    while (true)
    {
        out_grid_idxs.push_back({x0, y0});
        if (x0 == x1 && y0 == y1)
        {
            break;
        }

        double e2 = 2 * error;
        if (e2 >= dy)
        {
            if (x0 == x1)
            {
                break;
            }
            error += dy;
            x0 += sx;
        }
        if (e2 <= dx)
        {
            if (y0 == y1)
            {
                break;
            }
            error += dx;
            y0 += sy;
        }
    }
}

double FeatureExtractor::computeAngleTwoPlane_(
    const pcl::ModelCoefficients& coeff1, 
    const pcl::ModelCoefficients& coeff2)
{
    double a1 = coeff1.values[0];
    double b1 = coeff1.values[1];
    double c1 = coeff1.values[2];

    double a2 = coeff2.values[0];
    double b2 = coeff2.values[1];
    double c2 = coeff2.values[2];

    double angle = std::acos(a1 * a2 + b1 * b2 + c1 * c2);

    return angle;
}

double FeatureExtractor::computeHeightDiffTwoPlane_(
    const std::pair<double, double> boundary_point,
    const pcl::ModelCoefficients& coeff1, 
    const pcl::ModelCoefficients& coeff2)
{
    double a1 = coeff1.values[0];
    double b1 = coeff1.values[1];
    double d1 = coeff1.values[3];

    double a2 = coeff2.values[0];
    double b2 = coeff2.values[1];
    double d2 = coeff2.values[3];

    double x = boundary_point.first;
    double y = boundary_point.second;

    double dist1 = std::abs(a1 * x + b1 * y + d1);
    double dist2 = std::abs(a2 * x + b2 * y + d2); 

    return std::abs(dist1 - dist2);
}

template <class PointT>
void FeatureExtractor::removeInliner_(pcl::PointCloud<PointT>& cloud, 
                                      pcl::ModelCoefficients& coeff)
{
    Eigen::Vector4f plane_coeff = Eigen::Vector4f::Map(coeff.values.data(), 4);

    pcl::PointIndices::Ptr inliers(new pcl::PointIndices());
    pcl::ExtractIndices<PointT> extract;
    for (int i = 0; i < cloud.size(); ++i)
    {
        double distance = pcl::pointToPlaneDistance(cloud.points[i], plane_coeff);
        if (distance < setting_.FIT_PLANE_THRESHOLD)
        {
            inliers->indices.push_back(i);
        }
    }
    extract.setInputCloud(cloud.makeShared());
    extract.setIndices(inliers);
    extract.setNegative(true);
    extract.filter(cloud);
}
